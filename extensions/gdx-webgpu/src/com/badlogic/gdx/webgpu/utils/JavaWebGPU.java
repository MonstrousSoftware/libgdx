
package com.badlogic.gdx.webgpu.utils;

import com.badlogic.gdx.webgpu.webgpu.WebGPU_JNI;
import jnr.ffi.LibraryLoader;
import jnr.ffi.Runtime;
import jnr.ffi.Pointer;

import java.io.*;
import java.nio.ByteBuffer;
import java.util.zip.CRC32;

public class JavaWebGPU {

	/** The function bindings generated by jnr-ffi */
	private static Runtime runtime;
	private static WebGPU_JNI webGPU;
	private static WebGPUUtils_JNI utils;

	public static WebGPU_JNI init () {
		// prevent the temp directory with filling up with a new jffi dll every time you start up (at 138Kb each).
		// fix the name and reuse the DLL between runs. PR https://github.com/jnr/jffi/pull/99
		//
		System.setProperty("jffi.extract.name", "jffi.dll");

		// Copy the shared libraries from the JAR file to a temp directory for loading.
		String path = findTempDir();
		copyResource("dawn.dll", path);
		copyResource("webgpuUtils.dll", path);

		webGPU = LibraryLoader.create(WebGPU_JNI.class).search(path).load("dawn"); // load the library
		utils = LibraryLoader.create(WebGPUUtils_JNI.class).search(path).load("webgpuUtils"); // load the library
		runtime = Runtime.getRuntime(webGPU);
		return webGPU;
	}

	public static WebGPU_JNI getWebGPU () {
		return webGPU;
	}

	public static WebGPUUtils_JNI getUtils () {
		return utils;
	}

	private static String findTempDir () {
		// Temp directory with username in path.
		File directory = new File(System.getProperty("java.io.tmpdir") + "/java-to-webgpu." + System.getProperty("user.name"));
		if (!directory.exists()) {
			boolean ok = directory.mkdir();
			if (!ok) return null;
		}
		return directory.getAbsolutePath();
	}

	/** Copy resource to temp directory if it is not already there. */
	private static void copyResource (String name, String targetDir) {

		File targetFile = new File(targetDir + "\\" + name);
		if (targetFile.exists()) {
			InputStream input = JavaWebGPU.class.getResourceAsStream("/" + name);
			long crcSource = crc(input);
			long crcDest = crcSource + 1;
			try {
				FileInputStream copied = new FileInputStream(targetFile);
				crcDest = crc(copied);
			} catch (FileNotFoundException e) {
				throw new RuntimeException(e);
			}
			if (crcSource == crcDest) // same contents, nothing to do
				return;
		}
		// if we arrive here, the target file does not exist or has different content. Copy the resource to the target.
		copyResourceToFile(name, targetDir);
	}

	/** Copy resource to file in destination directory. */
	private static void copyResourceToFile (String name, String targetDir) {
		System.out.println("Copying file to " + targetDir);
		InputStream input = JavaWebGPU.class.getResourceAsStream("/" + name);
		if (input == null) throw new RuntimeException("Resource not found: " + name);
		File outputFile = new File(targetDir + "\\" + name);
		FileOutputStream output = null;

		try {
			output = new FileOutputStream(outputFile);
			byte[] buffer = new byte[4096];
			while (true) {
				int length = input.read(buffer);
				if (length == -1) break;
				output.write(buffer, 0, length);
			}
		} catch (IOException ex) {
			throw new RuntimeException("Error extracting file: " + name);
		} finally {
			try {
				input.close();
				if (output != null) output.close();
			} catch (Throwable ignored) {
			}
		}
	}

	/** Returns a CRC of the remaining bytes in the stream. */
	public static long crc (InputStream input) {
		if (input == null) throw new IllegalArgumentException("input cannot be null.");
		CRC32 crc = new CRC32();
		byte[] buffer = new byte[4096];
		try {
			while (true) {
				int length = input.read(buffer);
				if (length == -1) break;
				crc.update(buffer, 0, length);
			}
		} catch (Exception ex) {
		} finally {
			try {
				input.close();
			} catch (Throwable ignored) {
			}
		}
		return crc.getValue();
	}

	/** Wraps a series of long values in a pointer in direct memory. */
	public static Pointer createLongArrayPointer (long[] longs) {
		Pointer ptr = JavaWebGPU.createDirectPointer(longs.length * Long.BYTES);

		for (int i = 0; i < longs.length; i++) {
			ptr.putLongLong(i * Long.BYTES, longs[i]);
		}

		return ptr;
	}

	/** Wraps a series of integer values in a pointer in direct memory. */
	public static Pointer createIntegerArrayPointer (int[] ints) {
		Pointer ptr = JavaWebGPU.createDirectPointer(ints.length * Integer.BYTES);

		for (int i = 0; i < ints.length; i++) {
			ptr.putInt(i * Integer.BYTES, ints[i]);
		}

		return ptr;
	}

	/** Wraps a series of float values in a pointer in direct memory. */
	public static Pointer createFloatArrayPointer (float[] floats) {
		Pointer ptr = JavaWebGPU.createDirectPointer(floats.length * Float.BYTES);

		for (int i = 0; i < floats.length; i++) {
			ptr.putFloat(i * Float.BYTES, floats[i]); // MM said Integer
		}

		return ptr;
	}

	/** Copies the given data into a DirectByteBuffer and then returns the buffer's pointer
	 *
	 * @see ByteBuffer#allocateDirect(int) */
	public static Pointer createByteArrayPointer (byte[] bytes) {
		ByteBuffer dataBuffer = ByteBuffer.allocateDirect(bytes.length).put(bytes);
		dataBuffer.rewind();

		return JavaWebGPU.createByteBufferPointer(dataBuffer);
	}

	/** returns a null pointer */
	public static Pointer createNullPointer () {
		return Pointer.wrap(runtime, 0x00);
	}

	/** returns the pointer to the provided byte buffer.
	 *
	 * @throws IllegalArgumentException if buffer isn't using direct memory, or buffer.position != 0 */
	public static Pointer createByteBufferPointer (ByteBuffer buffer) {
		if (!buffer.isDirect()) {
			throw new IllegalArgumentException("Buffer must be direct!");
		}

		if (buffer.position() > 0) {
			throw new IllegalArgumentException("Buffer should have a position of zero!");
		}

		return Pointer.wrap(runtime, buffer);
	}

	/** a pointer in direct memory with the given size
	 *
	 * @param size (in bytes) space allocated for the pointer */
	public static Pointer createDirectPointer (int size) {
		return runtime.getMemoryManager().allocateDirect(size);
	}

	/** Used for unit testing only! */
	public static void setRuntime (Runtime runtime) {
		JavaWebGPU.runtime = runtime;
	}

	public static Runtime getRuntime () {
		return runtime;
	}
}
