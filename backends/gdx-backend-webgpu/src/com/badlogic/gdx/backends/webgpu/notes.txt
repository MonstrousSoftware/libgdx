Notes on webgpu backend.

4/5/2025:
Synced libgdx repo on 4/5/2005 (latest update from 27/04/2025). Version 1.13.2.
Uses Gradle 8.12.

Error message: This project uses AGP 8.7.3, latest supported AGP is 7.4.0.
It means the IDE doesn't support the required version of the Android Gradle Plugin.
This is fixed by updating Intellij IDEA to update 2025.1 (built April 15, 2025).

Started creating gdx-backend-webgpu by copying gdx-backend-lwjgl3 and renaming
everything Lwjgl3 to WebGPU.

For now, copied all the backend files even when it is not graphics API related,
e.g. audio. Accept or deal with the code duplication later.

How to deal with multiple platforms? We are now tied to the LWJGL3 one.

5/5/2025:
Created tests/gdx-tests-webgpu based on gdx-tests-lwjgl3.

Added the generated jnr files from webgpu-to-java (https://github.com/MonstrousSoftware/java-to-webgpu)
to the libgdx backend (backends.webgpu.webgpu) (maybe the folder name could be better).
Needed to adapt the jnr generator to create the correct package name and import statements.

Resource folder added under gdx-backend-webgpu for the DLL files. (todo subdir per platform).
Shader source was added as a String to the HelloTriangle code to avoid too many loose files.

HelloTriangle test now works (calling GLFW and native WebGPU directly).

WebGPUTest uses WebGPUApplication and some native WebGPU calls to render a triangle.
The listener needs to create its own render pass (this will later be done by SpriteBatch or ModelBatch),
while WebGPUWindow.update() obtains the next render surface and presents the target view.
Update: the command encoder is created and finished in Window, and can be obtained via app.getCommandEncoder(),
render pass is created in Listener (because you may want multiple render passes).

LibGDX supports multiple windows per application.  This does not work yet for WebGPU (crash).

For audio, the webgpu backend simply refers to the lwjgl3 backend, so we don't duplicate non-graphics code.
This means we can remove the audio subfolder from gdx-backend-webgpu.



6/5/2024:
Crash of Application.newWindow() was because of the sharedContext parameter which seems related to GL context.  Crash fixed by passing a 0 instead.
To think which resources should be maintained at window level rather than application level, e.g. surface, device?, queue?
Moved surface, device, queue, targetView and commandEncoder to Window.  Application exposes these resource to user code by passing the resources from the current window.
WebGPU initialisation is mostly done at Window level now.

WebGPUTest now can create multiple windows. Use a mouse click in the window to create a child window.
Application exits when last window is closed.

Note: had to rename the .github/workflows folder (as a way to disable the workflows) to avoid push conflicts with automatic formatting workflows
and getting regular emails about missing permissions.

Next steps:
- include WebGPU abstraction classes
- SpriteBatch / Mesh

Created a wrapper folder which contain Java convenience classes of several WebGPU concepts (device, adapter, command encoder, buffer, etc.)
The webgpu code in Window was adapted to use these classes.
To get the raw pointer to use e.g. in a webgpu function call, use the getHandle() method.

Instead of replicating the internals of libgdx SpriteBatch (e.g. using a Mesh) we use a version that is functionally equivalent.

WGPUTexture still needs to be aligned to Texture.

RenderPassBuilder and PipelineSpecification need cleaning up or replacing.

VertexAttributes is reinvented. To be aligned.

Added depth texture to Window. Applcation exports textureview and textureformat (needed to build render pass).

Strange bug: when creating a child window the listener.render() gets called before encoder is created.
In Application, currentWindow and window variables are somehow different.
Maybe because newWindow is called async from a mouse event, while the loop is iterating. (newWindow affects currentWindow, because
the window constructor needs it to point to the window under construction).

